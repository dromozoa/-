<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>昭和横濱物語</title>

  <!-- https://fonts.google.com/ -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=BIZ+UDPGothic&family=BIZ+UDPMincho&display=swap" rel="stylesheet">

  <link href="demeter.css" rel="stylesheet">
  <link href="demeter-font.css" rel="stylesheet">

  <link href="manifest.webmanifest" rel="manifest">
  <link href="favicon.ico" rel="icon" sizes="any">
  <link href="favicon.svg" rel="icon" type="image/svg+xml">
  <link href="apple-touch-icon.png" rel="apple-touch-icon">

  <!-- https://github.com/goldfire/howler.js#quick-start -->
  <script defer src="https://cdn.jsdelivr.net/npm/howler@2.2.3/dist/howler.min.js" integrity="sha256-D+v9meJzO2kOysLcNsgohfWBprXHO2WJWJj/hUhBX1s=" crossorigin="anonymous"></script>

  <!-- https://lil-gui.georgealways.com/#Guide#Installation -->
  <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js" integrity="sha256-nxA4RilDJhj/0KWgoBtzApRa21VuGjjinTHof84MK/0=" crossorigin="anonymous"></script>

  <script defer src="demeter.js"></script>
  <script defer src="demeter-jlreq.js"></script>
  <script defer src="demeter-scenario.js"></script>

  <style>
    #demeter-graph-marker {
      fill: #666;
      stroke: none;
    }

    .graph > svg g.edges {
      fill: none;
      stroke: #666;
      stroke-width: 0.5px;
      marker-end: url(#demeter-graph-marker);
    }

    .graph > svg g.nodes {
      fill: #666;
      stroke: none;
    }

    .choice > svg {
      fill: rgba(255, 255, 255, 0.2);
      stroke: #FFF;
      transition: all 0.5s;
    }

    .choice > svg:hover {
      stroke: #029D93;
    }

    .choice > svg:active {
      fill: rgba(2, 157, 147, 0.2);
      stroke: #029D93;
    }

    @media (hover: hover) {
      .choice > svg {
        cursor: pointer;
      }
    }
  </style>
</head>

<body style="
  margin: 0 0 0 24px;
  /*
  background-color: #000;
  */
  background-image: url(../output/bg.png);
  color: #FFF;
">

<div class="graph" style="
  position: absolute;
  top: 200px;
  right: 15px;
  height: 400px;
  overflow: auto;
">
$graph
</div>

<script>
document.addEventListener("DOMContentLoaded", async () => {
  const D = demeter;
  await D.boot();

  const start = performance.now();
  const result = await D.loadFontFaces(10000);
  console.log("loadFontFaces", performance.now() - start, result);

  const fontSize = 24;
  const font = "'Showa Yokohama Story', 'BIZ UDPMincho'";
  // const uiFont = "'Showa Yokohama Story', 'BIZ UDPGothic'";
  const uiFont = font;

  const outputNode = document.body.appendChild(document.createElement("div"));
  outputNode.style.height = D.numberToCss(document.documentElement.clientHeight);
  outputNode.style.font = D.numberToCss(fontSize) + " " + font;
  outputNode.style.overflow = "auto";
  outputNode.style.scrollSnapType = "y mandatory";

  window.addEventListener("resize", () => {
    outputNode.style.height = D.numberToCss(document.documentElement.clientHeight);
  });

  const speakerTable = {
    narrator: "\uE000",
    alice:    "アリス",
    danu:     "ダヌー",
    demeter:  "デメテル",
    yukio:    "ユキヲ",
    priest:   "神父",
    engineer: "課長",
    activist: "店主",
    steven:   "STEVEN",
  };

  const canvasWidth = 256;
  const canvasHeight = 64;
  const canvasNode = document.createElement("canvas");
  canvasNode.width = canvasWidth * devicePixelRatio;
  canvasNode.height = canvasHeight * devicePixelRatio;
  canvasNode.style.display = "block";
  canvasNode.style.position = "fixed";
  canvasNode.style.width = D.numberToCss(canvasWidth);
  canvasNode.style.height = D.numberToCss(canvasHeight);
  canvasNode.style.right = "15px";
  canvasNode.style.bottom = "15px";
  document.body.append(canvasNode);

  const audioVisualizer = {}

  const startAudioVisualizer = async () => {
    if (!Howler.masterGain) {
      return;
    }

    if (audioVisualizer.started) {
      return true;
    }
    audioVisualizer.started = true;

    const analyser = Howler.ctx.createAnalyser();
    analyser.fftSize = 256;
    analyser.connect(Howler.ctx.destination);
    Howler.masterGain.connect(analyser);

    const canvasContext = canvasNode.getContext("2d");
    const scale = devicePixelRatio;
    canvasContext.scale(scale, scale);

    const timeDomainData = new Float32Array(analyser.fftSize);
    const frequencyData = new Float32Array(analyser.fftSize / 2);

    const W = canvasWidth;
    const H = canvasHeight;
    const HH = H / 2;
    const maxDecibels = -30;
    const minDecibels = -100;
    const rangeDecibels = maxDecibels - minDecibels;

    while (!audioVisualizer.stop) {
      await D.requestAnimationFrame();
      analyser.getFloatTimeDomainData(timeDomainData);
      analyser.getFloatFrequencyData(frequencyData);

      canvasContext.clearRect(0, 0, W, H);

      canvasContext.fillStyle = "rgba(255, 255, 255, 0.5)";
      for (let i = 0; i < analyser.fftSize; ++i) {
        const v = timeDomainData[i];
        if (v > 0) {
          const h = HH * v;
          canvasContext.fillRect(i, HH - h, 1, h);
        } else {
          const h = HH * -v;
          canvasContext.fillRect(i, HH, 1, h);
        }
      }

      canvasContext.fillStyle = "rgba(255, 255, 255, 0.5)";
      for (let i = 0; i < analyser.frequencyBinCount; ++i) {
        // -30dB .. -100dB
        const v = (Math.max(minDecibels, Math.min(maxDecibels, frequencyData[i])) - minDecibels) / rangeDecibels;
        const h = H * v;
        canvasContext.fillRect(W - i * 2 - 2, HH - h * 0.5, 2, h);
      }
    }

    audioVisualizer.started = false;
    audioVisualizer.stop = false;
  };

  const observerMap = new Map();
  const observerParagraphPrev = parseInt(document.location.hash.replace(/^#/, ""), 10) || 1;
  let observerParagraph;

  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      const pid = entry.target.lastElementChild.dataset.pid;
      if (entry.isIntersecting) {
        observerMap.set(pid, entry.isIntersecting);
      } else {
        observerMap.delete(pid);
      }
    });
    const paragraph = Math.min(...observerMap.keys());
    if (observerParagraph !== paragraph) {
      observerParagraph = paragraph;
      history.replaceState(null, "", "#" + observerParagraph);
    }
  }, {
    root: outputNode,
    threshold: 0.5,
  });

  const GUI = lil.GUI;
  const gui = new GUI;

  const data = {
    lineLength: 25,
    layout: async () => await layout(data.lineLength),
    music: "diana33",
    volume: 1,
    play: () => playMusic(data.music, data.volume),
    stop: () => stopMusic(),
    scroll: () => {
      const paragraphNode = outputNode.querySelector(`[data-pid='${observerParagraphPrev}']`);
      if (paragraphNode) {
        paragraphNode.scrollIntoView({ behavior: "smooth" });
      }
    },
  };

  gui.add(data, "lineLength", 10, 40, 1).name("一行の文字数");
  const layoutController = gui.add(data, "layout").name("レイアウト");
  gui.add(data, "music", [ "diana33", "diana19", "diana23", "diana12", "vi03", "vi10" ]).name("BGM");
  const volumeController = gui.add(data, "volume", 0, 1, 0.05).name("BGMのボリューム");
  gui.add(data, "play").name("BGMを再生");
  gui.add(data, "stop").name("BGMを停止");
  gui.add(data, "scroll").name("前回の段落位置に移動");

  let music;

  const stopMusic = () => {
    if (music) {
      if (music.playing()) {
        music.stop();
      }
      music = undefined;
    }
  };

  const playMusic = (musicId, volume) => {
    stopMusic();
    const basename = "../output/music/sessions_" + musicId;
    music = new Howl({
      src: [ basename + ".webm", basename + ".mp3" ],
      autoplay: true,
      loop: true,
      volume: volume,
    });
    startAudioVisualizer();
  };

  volumeController.onChange(volume => {
    if (music) {
      music.volume(volume);
    }
  });

  let voiceList;

  const stopVoiceList = () => {
    if (voiceList) {
      voiceList.forEach(voice => {
        if (voice.playing()) {
          voice.stop();
        }
      });
      voiceList = undefined;
    }
  };

  const playVoiceList = (voiceIdList) => {
    stopVoiceList();
    voiceList = voiceIdList.map(voiceId => {
      const basename = "../output/voice/" + "0".repeat(Math.max(0, 4 - voiceId.length)) + voiceId
      return new Howl({ src: [ basename + ".webm", basename + ".mp3" ] });
    });
    voiceList.forEach((voice, i) => {
      const voiceId = voiceIdList[i];
      const nextVoice = voiceList[i + 1];
      voice.on("play", () => document.querySelector("[data-tid='" + voiceId + "']").style.backgroundColor = "#333");
      voice.on("stop", () => document.querySelector("[data-tid='" + voiceId + "']").style.backgroundColor = "transparent");
      voice.once("end", () => {
        document.querySelector("[data-tid='" + voiceId + "']").style.backgroundColor = "transparent";
        if (nextVoice) {
          setTimeout(() => nextVoice.play(), 400);
        }
      });
    });
    voiceList[0].play();
    startAudioVisualizer();
  };

  const layout = async lineLength => {
    layoutController.name("レイアウト中").disable();
    const start = performance.now();

    outputNode.replaceChildren();

    // 25文字→4行
    // 20文字→6行
    const maxWidth = fontSize * lineLength;
    const maxLines = Math.max(Math.floor(120 / lineLength), 4);
    const lineHeight = fontSize * 2;

    let tid = 0;
    for (let pid = 1; pid <= D.scenario.length; ++pid) {
      await D.requestAnimationFrame();
      const sourceParagraph = D.scenario[pid - 1];

      {
        const containerNode = document.createElement("div");
        containerNode.style.display = "flex";
        containerNode.style.lineHeight = D.numberToCss(lineHeight);
        containerNode.style.scrollSnapAlign = "start";

        const speakerNode = containerNode.appendChild(document.createElement("div"));
        speakerNode.textContent = speakerTable[sourceParagraph[0].speaker];
        speakerNode.style.flex = "none";
        speakerNode.style.width = D.numberToCss(fontSize * 5);
        speakerNode.addEventListener("click", ev => playVoiceList([...ev.target.nextElementSibling.children].map(textNode => textNode.dataset.tid)));

        const paragraphNode = containerNode.appendChild(document.createElement("div"));
        paragraphNode.style.flex = "none";
        paragraphNode.style.minHeight = D.numberToCss(maxLines * lineHeight);
        paragraphNode.dataset.pid = pid;

        const paragraph = D.parseParagraph(sourceParagraph[1], fontSize, font);

        let numLines = 0;
        paragraph.forEach(text => {
          const lines = D.composeText(text, maxWidth);
          numLines += lines.length;
          const textNode = paragraphNode.appendChild(D.layoutText(lines, fontSize, lineHeight));
          textNode.dataset.tid = ++tid;
        });

        if (numLines > maxLines) {
          paragraphNode.style.backgroundColor = "#300";
        }

        outputNode.append(containerNode);
        observer.observe(containerNode);
      }

      if (sourceParagraph[0].choices) {
        const containerNode = document.createElement("div");
        containerNode.style.font = D.numberToCss(fontSize) + " " + uiFont;

        sourceParagraph[0].choices.forEach((choice, i) => {
          const choiceNode = containerNode.appendChild(document.createElement("div"));
          choiceNode.className = "choice";
          choiceNode.style.position = "relative";
          choiceNode.style.width = D.numberToCss(fontSize * lineLength);

          const choiceText = D.parseText(choice.choice, fontSize, uiFont);
          const lines = D.composeText(choiceText, fontSize * (lineLength - 4));
          const textNode = choiceNode.appendChild(D.layoutText(lines, fontSize, lineHeight));
          textNode.style.position = "absolute";
          textNode.style.top = D.numberToCss(fontSize);
          textNode.style.left = D.numberToCss(fontSize * 2);
          textNode.style.pointerEvents = "none";

          if (choice.barcode) {
            const barcodeNode = choiceNode.appendChild(document.createElement("span"));
            barcodeNode.style.display = "inline-block";
            barcodeNode.style.position = "absolute";
            barcodeNode.style.top = D.numberToCss(fontSize);
            barcodeNode.style.right = D.numberToCss(fontSize * 0.5);
            barcodeNode.style.font = D.numberToCss(fontSize) + " 'Libre Barcode 128'";
            barcodeNode.style.lineHeight = D.numberToCss(fontSize);
            barcodeNode.style.pointerEvents = "none";
            barcodeNode.textContent = choice.barcode;
          }

          const choiceFrameNode = choiceNode.appendChild(D.createChoiceFrame(fontSize * lineLength, fontSize * 4, fontSize));
          choiceFrameNode.style.display = "block";
          choiceFrameNode.addEventListener("click", ev => {
            console.log(pid, i, choice.label);
          });
        });

        outputNode.append(containerNode);
      }
    }

    console.log("layout", performance.now() - start);
    layoutController.name("レイアウト").enable();
  };

  await layout(data.lineLength);

});
</script>

</body>
</html>
